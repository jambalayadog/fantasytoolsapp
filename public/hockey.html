<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NHL 2025-2026 Weekly Schedule</title>
    <link rel="stylesheet" href="/stylesheets/hockey/hockey-schedule.css">
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-FDN2CFRV8T"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-FDN2CFRV8T');
    </script>
</head>
<body>
    <div class="container">
        <h1>NHL 2025-2026 Weekly Schedule</h1>
        
        <div class="controls">
            <button id="prev-week-btn" class="nav-button">< Week</button>
            <button id="prev-day-btn" class="nav-button">< Day</button>
            <button id="today-btn" class="nav-button today-button">Loading...</button>
            <button id="next-day-btn" class="nav-button">> Day</button>
            <button id="next-week-btn" class="nav-button">> Week</button>
        </div>

        <div id="loading" class="loading">Loading hockey data...</div>
        <div id="error" class="error" style="display: none;"></div>
        
        <div class="table-container">
            <table id="schedule-table" class="schedule-table" style="display: none;">
                <thead>
                    <tr id="schedule-header-row">
                        <th class="sticky-column sortable" data-sort="team">Team <span class="sort-indicator"></span></th>
                        <th class="sticky-column sortable" data-sort="off">Off <span class="sort-indicator"></span></th>
                        <th class="sticky-column sortable" data-sort="def">Def <span class="sort-indicator"></span></th>
                        <th class="sticky-column sortable" data-sort="gp">GP <span class="sort-indicator"></span></th>
                        <!-- 7 day columns will be dynamically inserted here -->
                    </tr>
                </thead>
                <tbody id="schedule-tbody">
                    <!-- Content will be populated by JavaScript -->
                </tbody>
            </table>
        </div>

        <!-- Debug info hidden for production -->
        <!--
        <div id="debug-info" class="debug-info" style="display: none;">
            Debug information will be populated by JavaScript
        </div>
        -->
    </div>

    <script>
        // NHL Teams in the same order as your current site
        const NHL_TEAMS = [
            'ANA', 'BOS', 'BUF', 'CGY', 'CAR', 'CHI', 'COL', 'CBJ', 
            'DAL', 'DET', 'EDM', 'FLA', 'LAK', 'MIN', 'MTL', 'NSH',
            'NJD', 'NYI', 'NYR', 'OTT', 'PHI', 'PIT', 'SJS', 'SEA',
            'STL', 'TBL', 'TOR', 'UTA', 'VAN', 'VGK', 'WSH', 'WPG'
        ];

        const DAYS_OF_WEEK = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];

        let hockeyData = null;
        let allGames = {}; // Will store all games for entire season by team
        let currentStartDate = null; // Start date of current 7-day window
        let seasonStartMonday = null; // Will be calculated from first game
        let currentSortColumn = null; // Track which column is currently sorted
        let currentSortDirection = 'asc'; // 'asc' or 'desc'
        let tableData = []; // Store current table data for sorting

        // Initialize the page
        document.addEventListener('DOMContentLoaded', function() {
            fetchHockeyData();
            
            // Add event listeners for navigation buttons
            document.getElementById('prev-day-btn').addEventListener('click', function() {
                navigateDays(-1);
                if (window.gtag) {
                  window.gtag('event', 'click', {
                    event_category: 'Navigation',
                    event_label: 'Previous Day Button'
                  });
                }
            });
            
            document.getElementById('next-day-btn').addEventListener('click', function() {
                navigateDays(1);
                if (window.gtag) {
                  window.gtag('event', 'click', {
                    event_category: 'Navigation',
                    event_label: 'Next Day Button'
                  });
                }
            });
            
            document.getElementById('prev-week-btn').addEventListener('click', function() {
                navigateDays(-7);
                if (window.gtag) {
                  window.gtag('event', 'click', {
                    event_category: 'Navigation',
                    event_label: 'Previous Week Button'
                  });
                }
            });
            
            document.getElementById('next-week-btn').addEventListener('click', function() {
                navigateDays(7);
                if (window.gtag) {
                  window.gtag('event', 'click', {
                    event_category: 'Navigation',
                    event_label: 'Next Week Button'
                  });
                }
            });
            
            document.getElementById('today-btn').addEventListener('click', function() {
                resetToToday();
                if (window.gtag) {
                  window.gtag('event', 'click', {
                    event_category: 'Navigation',
                    event_label: 'Today Button'
                  });
                }
            });
            
            // Add event listener for window resize (mobile/desktop layout changes)
            // Only re-render if width changes (orientation/real resize), not height (address bar)
            let resizeTimeout;
            let lastWidth = window.innerWidth;
            
            window.addEventListener('resize', function() {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(function() {
                    const currentWidth = window.innerWidth;
                    const widthChange = Math.abs(currentWidth - lastWidth);
                    
                    // Only re-render if width changed by more than 50px (orientation change or real resize)
                    // Ignore height-only changes (address bar showing/hiding)
                    if (widthChange > 50) {
                        lastWidth = currentWidth;
                if (hockeyData) {
                    renderSchedule();
                }
                    }
                }, 250); // Wait 250ms after resize stops
            });
            
            // Add touch swipe functionality for mobile
            initializeTouchSwipe();
        });

        function initializeWeekSelector() {
            const select = document.getElementById('week-select');
            // Will be populated after data loads with actual available weeks
        }

        function isMobileDevice() {
            return window.innerWidth <= 768;
        }

        // Touch swipe functionality for mobile navigation
        function initializeTouchSwipe() {
            let startX = 0;
            let startY = 0;
            let endX = 0;
            let endY = 0;
            const minSwipeDistance = 50; // Minimum distance for a swipe
            const maxVerticalDistance = 100; // Maximum vertical movement to still count as horizontal swipe
            
            const scheduleTable = document.getElementById('schedule-table');
            
            scheduleTable.addEventListener('touchstart', function(e) {
                const touch = e.touches[0];
                startX = touch.clientX;
                startY = touch.clientY;
            }, { passive: true });
            
            scheduleTable.addEventListener('touchend', function(e) {
                const touch = e.changedTouches[0];
                endX = touch.clientX;
                endY = touch.clientY;
                
                handleSwipe();
            }, { passive: true });
            
            function handleSwipe() {
                const deltaX = endX - startX;
                const deltaY = Math.abs(endY - startY);
                const absDeltaX = Math.abs(deltaX);
                
                // Check if it's a horizontal swipe (not vertical scroll)
                // Horizontal movement must be:
                // 1. Greater than minimum distance (50px)
                // 2. At least 2x the vertical movement (to distinguish from vertical scroll)
                if (absDeltaX > minSwipeDistance && absDeltaX > deltaY * 2) {
                    if (deltaX > 0) {
                        // Swipe right - go to previous week
                        navigateWeek(-1);
                    } else {
                        // Swipe left - go to next week
                        navigateWeek(1);
                    }
                }
            }
        }
        
        function navigateWeek(direction) {
            if (!hockeyData) return;
            
            const availableWeeks = Object.keys(hockeyData.schedule)
                .map(w => parseInt(w))
                .sort((a, b) => a - b);
            
            const currentIndex = availableWeeks.indexOf(currentWeek);
            if (currentIndex === -1) return;
            
            let newIndex = currentIndex + direction;
            
            // Wrap around if at boundaries
            if (newIndex < 0) {
                newIndex = availableWeeks.length - 1;
            } else if (newIndex >= availableWeeks.length) {
                newIndex = 0;
            }
            
            const newWeek = availableWeeks[newIndex];
            if (newWeek !== currentWeek) {
                currentWeek = newWeek;
                
                // Update the select dropdown
                document.getElementById('week-select').value = currentWeek;
                
                // Re-render the schedule
                renderSchedule();
                
                // Update navigation button states
                updateNavigationButtons();
                
                // Optional: Show brief feedback
                showWeekChangeIndicator(direction);
            }
        }
        
        function updateNavigationButtons() {
            if (!hockeyData) return;
            
            const availableWeeks = Object.keys(hockeyData.schedule)
                .map(w => parseInt(w))
                .sort((a, b) => a - b);
            
            const currentIndex = availableWeeks.indexOf(currentWeek);
            const prevBtn = document.getElementById('prev-week-btn');
            const nextBtn = document.getElementById('next-week-btn');
            
            // Enable/disable buttons based on current position
            // Note: We allow wrap-around, so buttons are always enabled
            // But we could disable them at boundaries if preferred
            prevBtn.disabled = false;
            nextBtn.disabled = false;
            
            // Update button text to show week numbers
            const prevWeek = currentIndex > 0 ? availableWeeks[currentIndex - 1] : availableWeeks[availableWeeks.length - 1];
            const nextWeek = currentIndex < availableWeeks.length - 1 ? availableWeeks[currentIndex + 1] : availableWeeks[0];
            
            prevBtn.textContent = `< Week ${prevWeek}`;
            nextBtn.textContent = `Week ${nextWeek} >`;
        }
        
        function showWeekChangeIndicator(direction) {
            // Create a brief visual indicator for the swipe action
            const indicator = document.createElement('div');
            indicator.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.7);
                color: white;
                padding: 10px 20px;
                border-radius: 5px;
                font-size: 14px;
                z-index: 1000;
                pointer-events: none;
            `;
            indicator.textContent = direction > 0 ? 'Next Week →' : '← Previous Week';
            
            document.body.appendChild(indicator);
            
            // Remove after brief display
            setTimeout(() => {
                document.body.removeChild(indicator);
            }, 800);
        }

        function findNearestWeekWithGames(targetWeek, availableWeeks) {
            // Find the week with games closest to the target week
            let bestWeek = null;
            let minDistance = Infinity;
            
            availableWeeks.forEach(week => {
                const weekData = hockeyData.schedule[week.toString()];
                const teamsWithGames = Object.values(weekData).filter(games => games.length > 0).length;
                
                if (teamsWithGames > 0) {
                    const distance = Math.abs(week - targetWeek);
                    if (distance < minDistance) {
                        minDistance = distance;
                        bestWeek = week;
                    }
                }
            });
            
            return bestWeek;
        }

        function populateWeekSelector() {
            const select = document.getElementById('week-select');
            select.innerHTML = ''; // Clear existing options
            
            if (!hockeyData) return;
            
            const availableWeeks = Object.keys(hockeyData.schedule)
                .map(w => parseInt(w))
                .sort((a, b) => a - b); // Sort ascending for dropdown
            
            availableWeeks.forEach(week => {
                const weekData = hockeyData.schedule[week.toString()];
                const teamsWithGames = Object.values(weekData).filter(games => games.length > 0).length;
                
                const option = document.createElement('option');
                option.value = week;
                option.textContent = `Week ${week}${teamsWithGames === 0 ? ' (no games)' : ''}`;
                
                if (week === currentWeek) {
                    option.selected = true;
                }
                select.appendChild(option);
            });
        }

        async function fetchHockeyData() {
            try {
                clearError();
                showLoading(true);
                
                // Fetch data from server-generated local files
                const response = await fetch('/hockeytest/api/data');
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                hockeyData = await response.json();
                console.log('Hockey data loaded:', hockeyData);
                
                // Flatten all games by team across all weeks
                allGames = {};
                for (let team of NHL_TEAMS) {
                    allGames[team] = [];
                }
                
                for (let week in hockeyData.schedule) {
                    const weekData = hockeyData.schedule[week];
                    for (let team in weekData) {
                        if (weekData[team] && Array.isArray(weekData[team])) {
                            allGames[team].push(...weekData[team]);
                        }
                    }
                }
                
                // Sort games by date for each team
                for (let team in allGames) {
                    allGames[team].sort((a, b) => new Date(a.gamedate) - new Date(b.gamedate));
                }
                
                console.log('All games flattened and sorted by team');
                
                // Set initial window: today should be in the 5th column (index 4)
                // So start date is 4 days before today
                const today = new Date();
                today.setHours(0, 0, 0, 0); // Reset to midnight
                
                currentStartDate = new Date(today);
                currentStartDate.setDate(today.getDate() - 4); // 4 days before today
                
                console.log(`Initial window start: ${currentStartDate.toDateString()}`);
                console.log(`Today (5th column): ${today.toDateString()}`);
                
                updateTodayButton();
                renderSchedule();
                showLoading(false);
                
            } catch (error) {
                console.error('Error fetching hockey data:', error);
                showError('Error loading hockey data: ' + error.message);
                showLoading(false);
            }
        }

        function navigateDays(days) {
            if (!currentStartDate) return;
            
            currentStartDate.setDate(currentStartDate.getDate() + days);
            clearSort(); // Clear sort state when navigating
            renderSchedule();
        }

        function resetToToday() {
            // Reset to initial view: today in 5th column
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            currentStartDate = new Date(today);
            currentStartDate.setDate(today.getDate() - 4); // 4 days before today
            
            clearSort(); // Clear sort state when navigating
            renderSchedule();
        }

        function updateTodayButton() {
            // Update the today button to show current date
            const todayBtn = document.getElementById('today-btn');
            const today = new Date();
            
            const dayName = DAYS_OF_WEEK[today.getDay() === 0 ? 6 : today.getDay() - 1];
            const month = today.getMonth() + 1;
            const day = today.getDate();
            
            todayBtn.textContent = `Today (${dayName} ${month}/${day})`;
        }

        function updateTableHeaderWithDates(windowDates) {
            // Update the header row with actual dates for the 7-day window
            const headerRow = document.getElementById('schedule-header-row');
            
            // Remove any existing day columns
            const existingDayCols = headerRow.querySelectorAll('.day-column');
            existingDayCols.forEach(col => col.remove());
            
            // Get today's date normalized to midnight for comparison
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            
            // Append 7 date columns at the end of the header row
            windowDates.forEach((date, index) => {
                const th = document.createElement('th');
                th.className = 'day-column sortable';
                th.setAttribute('data-sort', `day${index}`);
                
                // Format: "Mon 10/7"
                const dayName = DAYS_OF_WEEK[date.getDay() === 0 ? 6 : date.getDay() - 1]; // Convert Sunday=0 to our format
                const month = date.getMonth() + 1;
                const day = date.getDate();
                
                th.innerHTML = `${dayName}<br>${month}/${day} <span class="sort-indicator"></span>`;
                th.style.fontSize = '11px';
                
                // Check if this date is today and add special class
                const dateNormalized = new Date(date);
                dateNormalized.setHours(0, 0, 0, 0);
                if (dateNormalized.getTime() === today.getTime()) {
                    th.classList.add('today-column');
                }
                
                headerRow.appendChild(th);
            });
        }

        function attachSortHandlers() {
            // Attach click handlers to all sortable headers
            // Use event delegation on the header row to avoid duplicate handlers
            const headerRow = document.getElementById('schedule-header-row');
            
            // Remove any existing handler first
            headerRow.removeEventListener('click', handleHeaderClick);
            
            // Add single delegated handler
            headerRow.addEventListener('click', handleHeaderClick);
            
            // Style all sortable headers
            const sortableHeaders = document.querySelectorAll('.sortable');
            sortableHeaders.forEach(header => {
                header.style.cursor = 'pointer';
            });
        }
        
        function handleHeaderClick(event) {
            // Find the clicked header (might be the th or a child element)
            const header = event.target.closest('.sortable');
            if (header) {
                const sortColumn = header.getAttribute('data-sort');
                sortTable(sortColumn);
            }
        }

        function clearSort() {
            // Clear sort state and indicators
            currentSortColumn = null;
            currentSortDirection = 'asc';
            updateSortIndicators();
        }


        function sortTable(column) {
            // Toggle direction if clicking the same column
            if (currentSortColumn === column) {
                currentSortDirection = currentSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                currentSortColumn = column;
                // Default sort direction: desc for numeric columns (show highest first), asc for team
                if (column === 'team' || column.startsWith('day')) {
                    currentSortDirection = 'asc';
                } else {
                    currentSortDirection = 'desc'; // off, def, gp show highest first
                }
            }

            // Sort the tableData array
            tableData.sort((a, b) => {
                let valA, valB;

                if (column === 'team') {
                    // Sort by position in NHL_TEAMS array (by city name order)
                    valA = NHL_TEAMS.indexOf(a.team);
                    valB = NHL_TEAMS.indexOf(b.team);
                    return currentSortDirection === 'asc' 
                        ? valA - valB
                        : valB - valA;
                } 
                else if (column === 'off') {
                    valA = a.offValue;
                    valB = b.offValue;
                    return currentSortDirection === 'asc' 
                        ? valA - valB
                        : valB - valA;
                } 
                else if (column === 'def') {
                    valA = a.defValue;
                    valB = b.defValue;
                    // For defense, lower is better, so default 'asc' should show best (lowest) first
                    return currentSortDirection === 'asc' 
                        ? valA - valB
                        : valB - valA;
                } 
                else if (column === 'gp') {
                    valA = a.gamesInWindow;
                    valB = b.gamesInWindow;
                    return currentSortDirection === 'asc' 
                        ? valA - valB
                        : valB - valA;
                } 
                else if (column.startsWith('day')) {
                    const dayIndex = parseInt(column.substring(3));
                    
                    const gameA = a.dayGames[dayIndex];
                    const gameB = b.dayGames[dayIndex];
                    
                    // Calculate priority:
                    // 1 = Has game (played or unplayed)
                    // 0 = No game (empty cell)
                    const getPriority = (game) => {
                        return game ? 1 : 0;
                    };
                    
                    const priorityA = getPriority(gameA);
                    const priorityB = getPriority(gameB);
                    
                    // If priorities differ, sort by priority
                    if (priorityA !== priorityB) {
                        // Ascending: Has game (1) → Empty (0)
                        // Descending: Empty (0) → Has game (1)
                        return currentSortDirection === 'asc' 
                            ? priorityB - priorityA
                            : priorityA - priorityB;
                    }
                    
                    // Same priority - if both have games, sort by time then game number then home/away
                    if (gameA && gameB) {
                        // Sort by game time
                        const timeA = new Date(gameA.startTimeUTC || gameA.gamedate).getTime();
                        const timeB = new Date(gameB.startTimeUTC || gameB.gamedate).getTime();
                        
                        if (timeA !== timeB) {
                            return currentSortDirection === 'asc'
                                ? timeA - timeB  // Earliest first
                                : timeB - timeA; // Latest first
                        }
                        
                        // Same time - sort by game number to keep opponents together
                        const gameNumA = gameA.gamenumber || 0;
                        const gameNumB = gameB.gamenumber || 0;
                        
                        if (gameNumA !== gameNumB) {
                            return gameNumA - gameNumB;
                        }
                        
                        // Same game - sort by home/away
                        // Home team = 1, Away team = 0
                        const isHomeA = gameA.hometeam === a.team ? 1 : 0;
                        const isHomeB = gameB.hometeam === b.team ? 1 : 0;
                        
                        // Ascending: Home (1) first, Away (0) second
                        // Descending: Away (0) first, Home (1) second
                        return currentSortDirection === 'asc'
                            ? isHomeB - isHomeA  // Home first
                            : isHomeA - isHomeB; // Away first
                    }
                    
                    return 0;
                }
                return 0;
            });

            // Update sort indicators
            updateSortIndicators();

            // Re-render the table with sorted data
            renderSortedTable();
        }

        function updateSortIndicators() {
            // Clear all indicators
            document.querySelectorAll('.sort-indicator').forEach(indicator => {
                indicator.textContent = '';
            });

            // Set indicator for current sort column
            const currentHeader = document.querySelector(`[data-sort="${currentSortColumn}"]`);
            if (currentHeader) {
                const indicator = currentHeader.querySelector('.sort-indicator');
                if (indicator) {
                    indicator.textContent = currentSortDirection === 'asc' ? ' ▲' : ' ▼';
                }
            }
        }


        function showLoading(show) {
            document.getElementById('loading').style.display = show ? 'block' : 'none';
            document.getElementById('schedule-table').style.display = show ? 'none' : 'table';
        }

        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.style.display = 'block';
            // Hide the table when showing error
            document.getElementById('schedule-table').style.display = 'none';
        }

        function clearError() {
            document.getElementById('error').style.display = 'none';
        }

        function calculateSeasonStartMonday() {
            // Find the first game in the entire season to calculate week 0 Monday
            let firstGameDate = null;
            
            // Look through all weeks to find the earliest game
            for (let week in hockeyData.schedule) {
                const weekData = hockeyData.schedule[week];
                for (let team in weekData) {
                    const games = weekData[team];
                    for (let game of games) {
                        const gameDate = new Date(game.gamedate);
                        if (!firstGameDate || gameDate < firstGameDate) {
                            firstGameDate = gameDate;
                        }
                    }
                }
            }
            
            if (firstGameDate) {
                // Calculate the Monday of the week containing the first game
                const dayOfWeek = firstGameDate.getDay(); // 0=Sunday, 1=Monday, ..., 6=Saturday
                const daysToSubtract = dayOfWeek === 0 ? 6 : dayOfWeek - 1; // Days back to Monday
                
                seasonStartMonday = new Date(firstGameDate);
                seasonStartMonday.setDate(firstGameDate.getDate() - daysToSubtract);
                
                console.log('First game found:', firstGameDate.toDateString());
                console.log('Season start Monday:', seasonStartMonday.toDateString());
            }
        }

        function getWeekDates(weekNumber) {
            if (!seasonStartMonday) return [];
            
            const dates = [];
            const weekStart = new Date(seasonStartMonday);
            weekStart.setDate(seasonStartMonday.getDate() + (weekNumber * 7));
            
            for (let i = 0; i < 7; i++) {
                const date = new Date(weekStart);
                date.setDate(weekStart.getDate() + i);
                dates.push(date);
            }
            
            return dates;
        }

        function updateTableHeader() {
            const weekDates = getWeekDates(currentWeek);
            
            // Update the date row
            const thead = document.querySelector('#schedule-table thead');
            
            // Remove existing date row if it exists
            const existingDateRow = thead.querySelector('.date-row');
            if (existingDateRow) {
                existingDateRow.remove();
            }
            
            // Create new date row
            const dateRow = document.createElement('tr');
            dateRow.className = 'date-row';
            
            // Empty cell for team column
            const emptyCell = document.createElement('th');
            emptyCell.textContent = '';
            dateRow.appendChild(emptyCell);
            
            // Empty cell for GF/GP column
            const emptyGfCell = document.createElement('th');
            emptyGfCell.textContent = '';
            dateRow.appendChild(emptyGfCell);
            
            // Empty cell for GA/GP column
            const emptyGaCell = document.createElement('th');
            emptyGaCell.textContent = '';
            dateRow.appendChild(emptyGaCell);
            
            // Add date cells for each day
            weekDates.forEach((date, index) => {
                const dateCell = document.createElement('th');
                const month = date.getMonth() + 1;
                const day = date.getDate();
                dateCell.textContent = `${month}/${day}`;
                dateCell.style.fontSize = '11px';
                dateCell.style.color = '#666';
                dateRow.appendChild(dateCell);
            });
            
            // Empty cell for GP column
            const gpCell = document.createElement('th');
            gpCell.textContent = '';
            dateRow.appendChild(gpCell);
            
            // Insert date row as first row
            thead.insertBefore(dateRow, thead.firstChild);
        }

        function renderSchedule() {
            if (!hockeyData || !allGames || !currentStartDate) {
                console.log('Data not ready for rendering');
                return;
            }

            console.log('Rendering schedule from:', currentStartDate.toDateString());

            const tbody = document.getElementById('schedule-tbody');
            tbody.innerHTML = '';

            const teamStats = hockeyData.teamStats;
            
            if (!teamStats) {
                showError('Team stats data not available');
                return;
            }

            // Calculate 7-day window
            const windowDates = [];
            for (let i = 0; i < 7; i++) {
                const date = new Date(currentStartDate);
                date.setDate(currentStartDate.getDate() + i);
                windowDates.push(date);
            }

            // Update table header with actual dates
            updateTableHeaderWithDates(windowDates);
            
            // Attach sort handlers after header is updated with day columns
            attachSortHandlers();

            // Calculate percentiles for GF/GP and GA/GP to determine arrow indicators
            const gfgpValues = [];
            const gagpValues = [];
            
            NHL_TEAMS.forEach(team => {
                const stats = teamStats[team];
                if (stats && stats.teamRecord_GamesPlayed > 0) {
                    gfgpValues.push(stats.teamRecord_GoalsFor / stats.teamRecord_GamesPlayed);
                    gagpValues.push(stats.teamRecord_GoalsAgainst / stats.teamRecord_GamesPlayed);
                }
            });
            
            // Sort and calculate 33rd and 67th percentiles
            gfgpValues.sort((a, b) => a - b);
            gagpValues.sort((a, b) => a - b);
            
            const gfgpLowThreshold = gfgpValues[Math.floor(gfgpValues.length / 3)];
            const gfgpHighThreshold = gfgpValues[Math.floor(gfgpValues.length * 2 / 3)];
            
            // For GA/GP, lower is better, so thresholds are reversed
            const gagpLowThreshold = gagpValues[Math.floor(gagpValues.length / 3)];
            const gagpHighThreshold = gagpValues[Math.floor(gagpValues.length * 2 / 3)];

            // Build table data array for all teams
            tableData = [];
            
            NHL_TEAMS.forEach(team => {
                const stats = teamStats[team];
                const offValue = stats ? (stats.teamRecord_GoalsFor / stats.teamRecord_GamesPlayed) : 0;
                const defValue = stats ? (stats.teamRecord_GoalsAgainst / stats.teamRecord_GamesPlayed) : 0;
                
                // Count games and store game data for each day
                const teamGames = allGames[team] || [];
                let gamesInWindow = 0;
                const dayGames = [];
                
                for (let dayIndex = 0; dayIndex < 7; dayIndex++) {
                    const windowDate = windowDates[dayIndex];
                    windowDate.setHours(0, 0, 0, 0);
                    
                    const gameForDay = teamGames.find(game => {
                        const gameDate = new Date(game.gamedate);
                        gameDate.setHours(0, 0, 0, 0);
                        return gameDate.getTime() === windowDate.getTime();
                    });
                    
                    dayGames.push(gameForDay || null);
                    if (gameForDay) gamesInWindow++;
                }
                
                tableData.push({
                    team: team,
                    stats: stats,
                    offValue: offValue,
                    defValue: defValue,
                    gamesInWindow: gamesInWindow,
                    dayGames: dayGames,
                    gfgpHighThreshold: gfgpHighThreshold,
                    gfgpLowThreshold: gfgpLowThreshold,
                    gagpHighThreshold: gagpHighThreshold,
                    gagpLowThreshold: gagpLowThreshold
                });
            });

            // Render the table
            renderSortedTable();
        }

        function getStatColor(value, isOffense, thresholds) {
            // Returns color class for stat indicators
            // isOffense: true for offense (higher is better), false for defense (lower is better)
            if (isOffense) {
                // Offense: higher is better
                if (value >= thresholds.high) return 'stat-indicator-good';
                if (value <= thresholds.low) return 'stat-indicator-bad';
            } else {
                // Defense: lower is better
                if (value <= thresholds.low) return 'stat-indicator-good';
                if (value >= thresholds.high) return 'stat-indicator-bad';
            }
            return 'stat-indicator-neutral';
        }

        function renderSortedTable() {
            const tbody = document.getElementById('schedule-tbody');
            tbody.innerHTML = '';
            
            // Array to store GP values and cells for styling after rendering
            const gpData = [];

            // Render each team row from tableData
            tableData.forEach(rowData => {
                const team = rowData.team;
                const row = document.createElement('tr');
                
                // Team name cell with logo only
                const teamCell = document.createElement('td');
                teamCell.className = 'team-cell';
                
                // Create team logo
                const teamLogo = document.createElement('img');
                teamLogo.src = `/images/${team}.png`;
                teamLogo.className = 'team-logo';
                teamLogo.alt = team;
                teamLogo.onerror = function() { this.style.display = 'none'; }; // Hide if logo doesn't exist
                
                teamCell.appendChild(teamLogo);
                teamCell.appendChild(document.createTextNode(` ${team}`));
                row.appendChild(teamCell);

                // GF/GP cell
                const stats = rowData.stats;
                const gfgpValue = rowData.offValue;
                const gfgp = gfgpValue.toFixed(1);
                const gfgpCell = document.createElement('td');
                gfgpCell.className = 'stat-cell sticky-column';
                
                // Create colored box for GF/GP (higher is better)
                const gfgpBox = document.createElement('span');
                gfgpBox.className = 'stat-value-box';
                gfgpBox.textContent = gfgp;
                
                if (stats && stats.teamRecord_GamesPlayed > 0) {
                    const colorClass = getStatColor(
                        gfgpValue, 
                        true, 
                        {high: rowData.gfgpHighThreshold, low: rowData.gfgpLowThreshold}
                    );
                    gfgpBox.classList.add(colorClass);
                }
                
                gfgpCell.appendChild(gfgpBox);
                row.appendChild(gfgpCell);
                
                // GA/GP cell
                const gagpValue = rowData.defValue;
                const gagp = gagpValue.toFixed(1);
                const gagpCell = document.createElement('td');
                gagpCell.className = 'stat-cell sticky-column';
                
                // Create colored box for GA/GP (lower is better for defense)
                const gagpBox = document.createElement('span');
                gagpBox.className = 'stat-value-box';
                gagpBox.textContent = gagp;
                
                if (stats && stats.teamRecord_GamesPlayed > 0) {
                    const colorClass = getStatColor(
                        gagpValue, 
                        false, 
                        {high: rowData.gagpHighThreshold, low: rowData.gagpLowThreshold}
                    );
                    gagpBox.classList.add(colorClass);
                }
                
                gagpCell.appendChild(gagpBox);
                row.appendChild(gagpCell);

                // Games count cell - create it now, will populate after rendering game cells
                const countCell = document.createElement('td');
                countCell.className = 'sticky-column gp-cell';
                row.appendChild(countCell);

                // Game cells for each day in the 7-day window
                for (let dayIndex = 0; dayIndex < 7; dayIndex++) {
                    const gameCell = document.createElement('td');
                    const gameForDay = rowData.dayGames[dayIndex];
                    
                    if (gameForDay) {
                        
                        const isHome = gameForDay.hometeam === team;
                        const opponent = isHome ? gameForDay.awayteam : gameForDay.hometeam;
                        const result = gameForDay.result;
                        
                        if (isMobileDevice()) {
                            // Mobile layout: stack opponent and score vertically
                            gameCell.className = 'mobile-game-cell';
                            
                            // Create mobile content wrapper
                            const mobileContent = document.createElement('div');
                            mobileContent.className = 'mobile-game-content';
                            
                            // Create opponent line (logo + name)
                            const opponentLine = document.createElement('div');
                            opponentLine.className = 'mobile-opponent-line';
                            
                            const opponentLogo = document.createElement('img');
                            opponentLogo.src = `/images/${opponent}.png`;
                            opponentLogo.className = 'opponent-logo';
                            opponentLogo.alt = opponent;
                            opponentLogo.onerror = function() { this.style.display = 'none'; };
                            
                            opponentLine.appendChild(opponentLogo);
                            opponentLine.appendChild(document.createTextNode(opponent));
                            mobileContent.appendChild(opponentLine);
                            
                            if (result === 'Final') {
                                // Create score line
                                const scoreLine = document.createElement('div');
                                scoreLine.className = 'mobile-score-line';
                                
                                const scoreSpan = document.createElement('span');
                                const overtimeMarker = (gameForDay.periodResult === 'OT' || gameForDay.periodResult === 'SO') ? '+' : '';
                                scoreSpan.textContent = `${gameForDay.teamResult} ${gameForDay.scoreResult}${overtimeMarker}`;
                                
                                if (gameForDay.teamResult === 'W') {
                                    scoreSpan.className = 'score-win';
                                } else {
                                    scoreSpan.className = 'score-loss';
                                }
                                
                                scoreLine.appendChild(scoreSpan);
                                mobileContent.appendChild(scoreLine);
                            } else {
                                // Game not final - show opponent stat indicators
                                const opponentData = tableData.find(d => d.team === opponent);
                                if (opponentData) {
                                    const indicatorLine = document.createElement('div');
                                    indicatorLine.className = 'mobile-indicator-line';
                                    
                                    // Offense indicator
                                    const offBox = document.createElement('span');
                                    offBox.className = 'stat-indicator ' + getStatColor(
                                        opponentData.offValue, 
                                        true, 
                                        {high: rowData.gfgpHighThreshold, low: rowData.gfgpLowThreshold}
                                    );
                                    indicatorLine.appendChild(offBox);
                                    
                                    // Defense indicator
                                    const defBox = document.createElement('span');
                                    defBox.className = 'stat-indicator ' + getStatColor(
                                        opponentData.defValue, 
                                        false, 
                                        {high: rowData.gagpHighThreshold, low: rowData.gagpLowThreshold}
                                    );
                                    indicatorLine.appendChild(defBox);
                                    
                                    mobileContent.appendChild(indicatorLine);
                                }
                            }
                            
                            gameCell.appendChild(mobileContent);
                            
                        } else {
                            // Desktop layout: split layout with team | info
                            const desktopContainer = document.createElement('div');
                            desktopContainer.className = 'desktop-game-container';
                            
                            // Left side: Team name/logo
                            const teamSide = document.createElement('div');
                            teamSide.className = 'desktop-game-team';
                            
                            const opponentLogo = document.createElement('img');
                            opponentLogo.src = `/images/${opponent}.png`;
                            opponentLogo.className = 'opponent-logo';
                            opponentLogo.alt = opponent;
                            opponentLogo.onerror = function() { this.style.display = 'none'; };
                            
                            teamSide.appendChild(opponentLogo);
                            teamSide.appendChild(document.createTextNode(opponent));
                            desktopContainer.appendChild(teamSide);
                            
                            // Right side: Score or indicators
                            const infoSide = document.createElement('div');
                            infoSide.className = 'desktop-game-info';
                                
                            if (result === 'Final') {
                                const scoreSpan = document.createElement('span');
                                const overtimeMarker = (gameForDay.periodResult === 'OT' || gameForDay.periodResult === 'SO') ? '+' : '';
                                scoreSpan.textContent = `${gameForDay.teamResult} ${gameForDay.scoreResult}${overtimeMarker}`;
                                
                                if (gameForDay.teamResult === 'W') {
                                    scoreSpan.className = 'score-win';
                                } else {
                                    scoreSpan.className = 'score-loss';
                                }
                                
                                infoSide.appendChild(scoreSpan);
                            } else {
                                // Game not final - show opponent stat indicators
                                const opponentData = tableData.find(d => d.team === opponent);
                                if (opponentData) {
                                    // Offense indicator
                                    const offBox = document.createElement('span');
                                    offBox.className = 'stat-indicator ' + getStatColor(
                                        opponentData.offValue, 
                                        true, 
                                        {high: rowData.gfgpHighThreshold, low: rowData.gfgpLowThreshold}
                                    );
                                    infoSide.appendChild(offBox);
                                    
                                    // Defense indicator
                                    const defBox = document.createElement('span');
                                    defBox.className = 'stat-indicator ' + getStatColor(
                                        opponentData.defValue, 
                                        false, 
                                        {high: rowData.gagpHighThreshold, low: rowData.gagpLowThreshold}
                                    );
                                    infoSide.appendChild(defBox);
                                }
                            }
                            
                            desktopContainer.appendChild(infoSide);
                            gameCell.appendChild(desktopContainer);
                        }
                        
                        // Add home/away styling to cell (both mobile and desktop)
                        if (!isHome) {
                            if (isMobileDevice()) {
                                gameCell.classList.add('game-away');
                            } else {
                                gameCell.className = 'game-away';
                            }
                        } else {
                            if (isMobileDevice()) {
                                gameCell.classList.add('game-home');
                            } else {
                                gameCell.className = 'game-home';
                            }
                        }
                    } else {
                        gameCell.textContent = '';
                    }
                    
                    row.appendChild(gameCell);
                }

                // Now populate the GP cell with the count
                countCell.textContent = rowData.gamesInWindow;

                // Store GP value and cell for styling later
                gpData.push({ value: rowData.gamesInWindow, cell: countCell });

                tbody.appendChild(row);
            });

            // Apply GP column styling based on value ranking
            if (gpData.length > 0) {
                // Get unique GP values and sort them descending
                const uniqueValues = [...new Set(gpData.map(item => item.value))].sort((a, b) => b - a);
                
                // Apply colors based on rank:
                // 1st (highest) = green, 2nd = none, 3rd = red, 4th+ (lowest) = purple
                gpData.forEach(item => {
                    const rank = uniqueValues.indexOf(item.value);
                    
                    if (rank === 0) {
                        // Highest value
                        item.cell.classList.add('gp-highest');
                    } else if (rank === 1) {
                        // Second highest - no color (neutral)
                        // Do nothing
                    } else if (rank === 2) {
                        // Third highest
                        item.cell.classList.add('gp-third');
                    } else if (rank >= 3) {
                        // Lowest (fourth or lower)
                        item.cell.classList.add('gp-lowest');
                    }
                });
            }

            // Debug info hidden for production
        }
    </script>
</body>
</html> 